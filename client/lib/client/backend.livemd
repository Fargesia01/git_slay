# BackEnd

```elixir
defmodule VectorClock do
  @moduledoc """
  Vector clock library for Elixir.

  ## About

  Vector clocks are used in distributed systems as a way of maintaining a
  logical ordering of events. A vector clock consists of a list of entries, each
  of which represents a node in a distributed system. A node entry consists of a
  name (unique identifier) and a timestamp. When a node sends an event to another
  node, it increments its timestamp in its vector clock and sends the clock along
  with the message. A node receiving a message can determine whether it has seen
  the effect of that message already by comparing its vector clock with the
  received vector clock.

  This module only contains the minimal set of functions for creating, updating
  comparing vector clocks. It was intentionally kept as simple as possible and
  misses many functions (e.g., min, max, length) helpful in developing
  real-world applications.

  ## Source

  This code was partly borrowed from several sources on the Internet (which I
  could not track down). It solely serves as an example as part of teaching
  material. The original sources should be recovered and cited if used in any
  other context.

  ## References

  Leslie Lamport (1978).
  [Time, clocks, and the ordering of events in a distributed system](https://doi.org/10.1145/359545.359563).
  Communications of the ACM 21 (7): 558-565.

  Friedemann Mattern (1988).
  [Virtual Time and Global States of Distributed Systems](https://nylas.github.io/paper-reading-group/papers/Virtual_Time.pdf).
  Workshop on Parallel and Distributed Algorithms.
  """

  @doc """
  Create a new vector clock for a list of nodes (or a single node) with timestamps initialised to `time` (0 by default).
  """
  def create(nodes, time \\ 0) do
    Map.new((if is_list(nodes), do: nodes, else: [nodes]), fn n -> {n, time} end)
  end

  @doc """
  Set the value of `vc` timestamp at `node` to `time`.
  """
  def set(vc, node, time) do
    Map.put(vc, node, time)
  end

  @doc """
  Get the value of `vc` timestamp at `node`.
  """
  def get(vc, node) do
    Map.get(vc, node, 0)
  end

  @doc """
  Increment `vc` timestamp at `node` by `step` (1 by default).
  """
  def increment(vc, node, step \\ 1) do
    set(vc, node, get(vc, node) + step)
  end

  @doc """
  Merge two vector clocks, `vc_a` and `vc_b`, by combining the maximum of each entry.
  """
  def merge(vc_a, vc_b) do
    Map.merge(vc_a, vc_b, fn _k, v1, v2 -> max(v1, v2) end)
  end

  @doc """
  Compare two vector clocks, `vc_a` and `vc_b`, according to the following rules.
  * `vc_a` is **less** than `vc_b` if and only if:
    1. for all i, `vc_a[i] <= vc_b[i]`; and
    2. there exists j such that `vc_a[j] < vc_b[j]`.
  * `vc_a` is **greater** than `vc_b` if `vc_b` is less than `vc_a`.
  * `vc_a` and `vc_b` are **equal** if for all i, `vc_a[i] == vc_b[i]` (and conversely).
  * `vc_a` and `vc_b` are **concurrent** if `vc_a` is not equal to, less than, or greater than `vc_b`.

  If a node is present in one of the vector clocks only, we assume its timestamp is 0 in the other.
  """
  def compare(vc_a, vc_b) do
    # Augment vector clock with missing keys (from other vector clock)
    a = Map.merge(Map.new(Map.keys(vc_b), fn k -> {k, 0} end), vc_a)
    b = Map.merge(Map.new(Map.keys(vc_a), fn k -> {k, 0} end), vc_b)

    cond do
      lt?(a, b) -> :less
      lt?(b, a) -> :greater
      eq?(a, b) -> :equal
      cc?(a, b) -> :concurrent
    end
  end

  defp lt?(vc_a, vc_b) do
    for_all = Enum.all?(vc_a, fn {node, time} -> time <= vc_b[node] end)
    exists = Enum.any?(vc_a, fn {node, time} -> time < vc_b[node] end)
    for_all and exists
  end

  defp eq?(vc_a, vc_b) do
    not Enum.any?(vc_a, fn {node, time} -> time != vc_b[node] end)
  end

  defp cc?(vc_a, vc_b) do
    not (lt?(vc_a, vc_b) or lt?(vc_b, vc_a) or eq?(vc_a, vc_b))
  end
end

defmodule COVC do
  
end
```

## Section

```elixir
defmodule BackEnd do
  @moduledoc """
  Ce module sert à représenter toutes les actions qui devront être prises en charge par les utilisateurs individuellement.
  Les différentes responsabilités sont :      
    gérer les demandes d'existance de document (donc recevoir les messages et répondre avec les versions ou nil)
    gérer les demandes d'envoi de document (donc fichier spécifique demandé)
    gérer les envois de demande de documents (donc quelles versions existent et recevoir le document demandé)      

  need interaction with UI for :
    function for requesting document
    function for displaying info about the versions
  """

  @splitChars "--"
  @filesPath (__ENV__.file |> String.split("lib/") |> hd()) <> "priv/files/"
  @record Path.wildcard(@filesPath <> "commit/*")
          |> Enum.filter(&File.regular?(&1))
          |> Enum.reduce(%{}, fn f, acc ->
            [fileName, version] = Path.rootname(f) |> String.split(@splitChars, parts: 2)

            Map.update(acc, fileName, [version], fn versions -> [version | versions] end)
          end)
  # define by calling server with http
  @mostRecentVersions

  # Segment of functions acting as endpoints for the page controller
  @doc """
  Returns all files that are saved locally
  """
  def getAllFiles() do
    for key <- @record, into: %{}, do: {key, Enum.max(Map.get(@record, key))}
    # check if I have to put it in a list or do 2 functions
  end

  @doc """
  Returns all the versions of the given file that are saved locally.
  """
  def getAllVersions(file) do
    try do
      Map.fetch!(@record, file)
    rescue
      KeyError -> nil
    end
  end

  @doc """
  Returns the data of the given file and version.
  """
  def getFileWithVersion(file, ver) do
    try do
      File.read!(@filesPath <> "commit/#{file}#{@splitChars}#{ver}")
    rescue
      File.Error -> nil
    end
  end

  @doc """
  Saves the given file and version locally. Returns #{:ok} if successful, #{nil} otherwise
  """
  def saveFile(path \\ @filesPath <> "commit/", file, ver, data) do
    File.write!(path <> "#{file}#{@splitChars}#{ver}", data)
  end

  def pull(file, ver \\ nil) do
    if ver == nil do
      Enum.max(Map.get(@mostRecentVersions, file))
    end

    data =
      try do
        File.read!(@filesPath <> "commit/#{file}#{@splitChars}#{ver}")
      rescue
        # add getting the response for the file form http
        File.Error -> nil
      end

    saveFile(file, ver, data)
    File.cp!(@filesPath <> "commit/#{file}#{@splitChars}#{ver}", @filesPath <> "user/#{file}")
  end
end
```
